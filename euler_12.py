# Highly divisible triangular number

# The sequence of triangle numbers is generated by adding the natural numbers.
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?
# Avichai Ben David


import itertools
import math
import time
import eulerlib

NUM_FACTORS = 1000
NUM_OF_PRIMES = 65500


def num_divisor(n):
    end = int(math.sqrt(n))
    result = sum(2 for i in range(1, end + 1) if n % i == 0)
    if end ** 2 == n:
        result -= 1
    return result


def compute():
    triangle = 0
    for i in itertools.count(1):
        triangle += i
        if num_divisor(triangle) > NUM_FACTORS:
            return triangle


def num_div(n):
    res = 0
    end = int(math.sqrt(n))
    for i in range(1, end + 1):
        if n % i == 0:
            res += 2
    if end ** 2 == n:
        res -= 1
    return res


def compute1():
    i = 2
    res = 1
    while True:
        res += i
        i += 1
        numb_dividers = num_div(res)
        if numb_dividers >= NUM_FACTORS:
            return res


def get_list_primes(n_of_primes):
    n = 3
    lst = [2]
    while len(lst) < n_of_primes:
        if eulerlib.is_prime(n):
            lst.append(n)
        n += 2
    return lst


def count_divisors(lst, temp_res, cnt):
    # When the prime divisor would be greater than the residual tt,
    # that residual tt is the last prime factor with an exponent=1
    # No necessity to identify it.
    for i in range(0, len(lst)):
        if lst[i] * lst[i] > temp_res:
            cnt *= 2
            break
        exponent = 1
        while temp_res % lst[i] == 0:
            exponent += 1
            temp_res /= lst[i]
        cnt *= exponent
        if temp_res == 1:
            break
    return cnt


def compute2():
    lst = get_list_primes(NUM_OF_PRIMES)
    res = 1
    a = 1
    cnt = 0
    while cnt <= NUM_FACTORS:
        cnt = 1
        a += 1
        res += a
        temp_res = res
        cnt = count_divisors(lst, temp_res, cnt)
    return res


if __name__ == "__main__":
    before = int(round(time.time() * 1000))
    print(compute2())
    after = int(round(time.time() * 1000))
    print(after - before)


# print(compute1())
# print(compute())
